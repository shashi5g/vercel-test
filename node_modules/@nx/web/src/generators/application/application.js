"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applicationSchematic = exports.applicationGeneratorInternal = exports.applicationGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const js_1 = require("@nx/js");
const versions_1 = require("@nx/js/src/utils/versions");
const path_1 = require("path");
const versions_2 = require("../../utils/versions");
const init_1 = require("../init/init");
function createApplicationFiles(tree, options) {
    (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, options.bundler === 'vite' ? './files/app-vite' : './files/app-webpack'), options.appProjectRoot, {
        ...options,
        ...(0, devkit_1.names)(options.name),
        tmpl: '',
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.appProjectRoot),
        rootTsConfigPath: (0, js_1.getRelativePathToRootTsConfig)(tree, options.appProjectRoot),
    });
    if (options.unitTestRunner === 'none') {
        tree.delete((0, path_1.join)(options.appProjectRoot, './src/app/app.element.spec.ts'));
    }
}
async function setupBundler(tree, options) {
    const main = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/main.ts');
    const tsConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json');
    const assets = [
        (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/favicon.ico'),
        (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/assets'),
    ];
    if (options.bundler === 'webpack') {
        const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/webpack', versions_2.nxVersion);
        await configurationGenerator(tree, {
            project: options.projectName,
            main,
            tsConfig,
            compiler: options.compiler ?? 'babel',
            devServer: true,
            webpackConfig: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js'),
            skipFormat: true,
        });
        const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
        const prodConfig = project.targets.build.configurations.production;
        const buildOptions = project.targets.build.options;
        buildOptions.assets = assets;
        buildOptions.index = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/index.html');
        buildOptions.baseHref = '/';
        buildOptions.styles = [
            (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/styles.${options.style}`),
        ];
        // We can delete that, because this projest is an application
        // and applications have a .babelrc file in their root dir.
        // So Nx will find it and use it
        delete buildOptions.babelUpwardRootMode;
        buildOptions.scripts = [];
        prodConfig.fileReplacements = [
            {
                replace: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.ts`),
                with: (0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/environments/environment.prod.ts`),
            },
        ];
        prodConfig.optimization = true;
        prodConfig.outputHashing = 'all';
        prodConfig.sourceMap = false;
        prodConfig.namedChunks = false;
        prodConfig.extractLicenses = true;
        prodConfig.vendorChunk = false;
        (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
    }
    else if (options.bundler === 'none') {
        // TODO(jack): Flush this out... no bundler should be possible for web but the experience isn't holistic due to missing features (e.g. writing index.html).
        const project = (0, devkit_1.readProjectConfiguration)(tree, options.projectName);
        project.targets.build = {
            executor: `@nx/js:${options.compiler}`,
            outputs: ['{options.outputPath}'],
            options: {
                main,
                outputPath: (0, devkit_1.joinPathFragments)('dist', options.appProjectRoot),
                tsConfig,
                assets,
            },
        };
        (0, devkit_1.updateProjectConfiguration)(tree, options.projectName, project);
    }
    else {
        throw new Error('Unsupported bundler type');
    }
}
async function addProject(tree, options) {
    const targets = {};
    (0, devkit_1.addProjectConfiguration)(tree, options.projectName, {
        projectType: 'application',
        root: options.appProjectRoot,
        sourceRoot: (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src'),
        tags: options.parsedTags,
        targets,
    }, options.standaloneConfig);
    if (options.bundler !== 'vite') {
        await setupBundler(tree, options);
    }
}
function setDefaults(tree, options) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    nxJson.generators = nxJson.generators || {};
    nxJson.generators['@nx/web:application'] = {
        style: options.style,
        linter: options.linter,
        unitTestRunner: options.unitTestRunner,
        e2eTestRunner: options.e2eTestRunner,
        ...nxJson.generators['@nx/web:application'],
    };
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
async function applicationGenerator(host, schema) {
    return await applicationGeneratorInternal(host, {
        projectNameAndRootFormat: 'derived',
        ...schema,
    });
}
exports.applicationGenerator = applicationGenerator;
async function applicationGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    const tasks = [];
    const webTask = await (0, init_1.webInitGenerator)(host, {
        ...options,
        skipFormat: true,
    });
    tasks.push(webTask);
    createApplicationFiles(host, options);
    await addProject(host, options);
    if (options.bundler === 'vite') {
        const { viteConfigurationGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
        // We recommend users use `import.meta.env.MODE` and other variables in their code to differentiate between production and development.
        // See: https://vitejs.dev/guide/env-and-mode.html
        if (host.exists((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'))) {
            host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, 'src/environments'));
        }
        const viteTask = await viteConfigurationGenerator(host, {
            uiFramework: 'none',
            project: options.projectName,
            newProject: true,
            includeVitest: options.unitTestRunner === 'vitest',
            inSourceTests: options.inSourceTests,
            skipFormat: true,
        });
        tasks.push(viteTask);
    }
    if (options.bundler !== 'vite' && options.unitTestRunner === 'vitest') {
        const { vitestGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_2.nxVersion);
        const vitestTask = await vitestGenerator(host, {
            uiFramework: 'none',
            project: options.projectName,
            coverageProvider: 'c8',
            inSourceTests: options.inSourceTests,
            skipFormat: true,
        });
        tasks.push(vitestTask);
    }
    if ((options.bundler === 'vite' || options.unitTestRunner === 'vitest') &&
        options.inSourceTests) {
        host.delete((0, devkit_1.joinPathFragments)(options.appProjectRoot, `src/app/app.element.spec.ts`));
    }
    if (options.linter === 'eslint') {
        const { lintProjectGenerator } = (0, devkit_1.ensurePackage)('@nx/linter', versions_2.nxVersion);
        const lintTask = await lintProjectGenerator(host, {
            linter: options.linter,
            project: options.projectName,
            tsConfigPaths: [
                (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'tsconfig.app.json'),
            ],
            unitTestRunner: options.unitTestRunner,
            eslintFilePatterns: [`${options.appProjectRoot}/**/*.ts`],
            skipFormat: true,
            setParserOptionsProject: options.setParserOptionsProject,
        });
        tasks.push(lintTask);
    }
    if (options.e2eTestRunner === 'cypress') {
        const { cypressProjectGenerator } = (0, devkit_1.ensurePackage)('@nx/cypress', versions_2.nxVersion);
        const cypressTask = await cypressProjectGenerator(host, {
            ...options,
            name: options.e2eProjectName,
            directory: options.e2eProjectRoot,
            // the name and root are already normalized, instruct the generator to use them as is
            projectNameAndRootFormat: 'as-provided',
            project: options.projectName,
            skipFormat: true,
        });
        tasks.push(cypressTask);
    }
    else if (options.e2eTestRunner === 'playwright') {
        const { configurationGenerator: playwrightConfigGenerator } = (0, devkit_1.ensurePackage)('@nx/playwright', versions_2.nxVersion);
        (0, devkit_1.addProjectConfiguration)(host, options.e2eProjectName, {
            root: options.e2eProjectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.e2eProjectRoot, 'src'),
            projectType: 'application',
            targets: {},
            implicitDependencies: [options.projectName],
        });
        const playwrightTask = await playwrightConfigGenerator(host, {
            project: options.e2eProjectName,
            skipFormat: true,
            skipPackageJson: false,
            directory: 'src',
            js: false,
            linter: options.linter,
            setParserOptionsProject: options.setParserOptionsProject,
            webServerCommand: `${(0, devkit_1.getPackageManagerCommand)().exec} nx serve ${options.name}`,
            webServerAddress: 'http://localhost:4200',
        });
        tasks.push(playwrightTask);
    }
    if (options.unitTestRunner === 'jest') {
        const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/jest', versions_2.nxVersion);
        const jestTask = await configurationGenerator(host, {
            project: options.projectName,
            skipSerializers: true,
            setupFile: 'web-components',
            compiler: options.compiler,
            skipFormat: true,
        });
        tasks.push(jestTask);
    }
    if (options.compiler === 'swc') {
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(options.appProjectRoot, '.swcrc'), {
            jsc: {
                parser: {
                    syntax: 'typescript',
                },
                target: 'es2016',
            },
        });
        const installTask = (0, devkit_1.addDependenciesToPackageJson)(host, {}, { '@swc/core': versions_1.swcCoreVersion, 'swc-loader': versions_2.swcLoaderVersion });
        tasks.push(installTask);
    }
    else {
        (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(options.appProjectRoot, '.babelrc'), {
            presets: ['@nx/js/babel'],
        });
    }
    setDefaults(host, options);
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.applicationGeneratorInternal = applicationGeneratorInternal;
async function normalizeOptions(host, options) {
    const { projectName: appProjectName, projectRoot: appProjectRoot, projectNameAndRootFormat, } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(host, {
        name: options.name,
        projectType: 'application',
        directory: options.directory,
        projectNameAndRootFormat: options.projectNameAndRootFormat,
        callingGenerator: '@nx/web:application',
    });
    options.projectNameAndRootFormat = projectNameAndRootFormat;
    const e2eProjectName = `${appProjectName}-e2e`;
    const e2eProjectRoot = `${appProjectRoot}-e2e`;
    const { npmScope } = (0, devkit_1.getWorkspaceLayout)(host);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    if (options.bundler === 'vite' && !options.unitTestRunner) {
        options.unitTestRunner = 'vitest';
    }
    options.style = options.style || 'css';
    options.linter = options.linter || 'eslint';
    options.unitTestRunner = options.unitTestRunner || 'jest';
    options.e2eTestRunner = options.e2eTestRunner || 'cypress';
    return {
        ...options,
        prefix: options.prefix ?? npmScope ?? 'app',
        name: (0, devkit_1.names)(options.name).fileName,
        compiler: options.compiler ?? 'babel',
        bundler: options.bundler ?? 'webpack',
        projectName: appProjectName,
        appProjectRoot,
        e2eProjectRoot,
        e2eProjectName,
        parsedTags,
    };
}
exports.default = applicationGenerator;
exports.applicationSchematic = (0, devkit_1.convertNxGenerator)(applicationGenerator);
