"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentSchematic = exports.componentGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const add_styled_dependencies_1 = require("../../rules/add-styled-dependencies");
const assertion_1 = require("../../utils/assertion");
const ast_utils_1 = require("../../utils/ast-utils");
const get_in_source_vitest_tests_template_1 = require("../../utils/get-in-source-vitest-tests-template");
const versions_1 = require("../../utils/versions");
const get_component_tests_1 = require("./get-component-tests");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const path_1 = require("path");
async function componentGenerator(host, schema) {
    const options = await normalizeOptions(host, schema);
    createComponentFiles(host, options);
    const tasks = [];
    const styledTask = (0, add_styled_dependencies_1.addStyledModuleDependencies)(host, options);
    tasks.push(styledTask);
    addExportsToBarrel(host, options);
    if (options.routing) {
        const routingTask = (0, devkit_1.addDependenciesToPackageJson)(host, { 'react-router-dom': versions_1.reactRouterDomVersion }, {});
        tasks.push(routingTask);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.componentGenerator = componentGenerator;
function createComponentFiles(host, options) {
    const componentDir = (0, devkit_1.joinPathFragments)(options.projectSourceRoot, options.directory);
    const componentTests = (0, get_component_tests_1.getComponentTests)(options);
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files'), componentDir, {
        ...options,
        componentTests,
        inSourceVitestTests: (0, get_in_source_vitest_tests_template_1.getInSourceVitestTestsTemplate)(componentTests),
        tmpl: '',
    });
    for (const c of host.listChanges()) {
        let deleteFile = false;
        if ((options.skipTests || options.inSourceTests) &&
            /.*spec.tsx/.test(c.path)) {
            deleteFile = true;
        }
        if ((options.styledModule || !options.hasStyles) &&
            c.path.endsWith(`.${options.style}`)) {
            deleteFile = true;
        }
        if (options.globalCss && c.path.endsWith(`.module.${options.style}`)) {
            deleteFile = true;
        }
        if (!options.globalCss &&
            c.path.endsWith(`${options.fileName}.${options.style}`)) {
            deleteFile = true;
        }
        if (deleteFile) {
            host.delete(c.path);
        }
    }
    if (options.js) {
        (0, devkit_1.toJS)(host);
    }
}
let tsModule;
function addExportsToBarrel(host, options) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    const workspace = (0, devkit_1.getProjects)(host);
    const isApp = workspace.get(options.project).projectType === 'application';
    if (options.export && !isApp) {
        const indexFilePath = (0, devkit_1.joinPathFragments)(options.projectSourceRoot, options.js ? 'index.js' : 'index.ts');
        const indexSource = host.read(indexFilePath, 'utf-8');
        if (indexSource !== null) {
            const indexSourceFile = tsModule.createSourceFile(indexFilePath, indexSource, tsModule.ScriptTarget.Latest, true);
            const changes = (0, devkit_1.applyChangesToString)(indexSource, (0, ast_utils_1.addImport)(indexSourceFile, `export * from './${options.directory}/${options.fileName}';`));
            host.write(indexFilePath, changes);
        }
    }
}
async function normalizeOptions(host, options) {
    assertValidOptions(options);
    const { className, fileName } = (0, devkit_1.names)(options.name);
    const componentFileName = options.fileName ?? (options.pascalCaseFiles ? className : fileName);
    const project = (0, devkit_1.getProjects)(host).get(options.project);
    if (!project) {
        devkit_1.logger.error(`Cannot find the ${options.project} project. Please double check the project name.`);
        throw new Error();
    }
    const { sourceRoot: projectSourceRoot, projectType } = project;
    const directory = await getDirectory(host, options);
    const styledModule = /^(css|scss|less|styl|none)$/.test(options.style)
        ? null
        : options.style;
    if (options.export && projectType === 'application') {
        devkit_1.logger.warn(`The "--export" option should not be used with applications and will do nothing.`);
    }
    options.classComponent = options.classComponent ?? false;
    options.routing = options.routing ?? false;
    options.globalCss = options.globalCss ?? false;
    options.inSourceTests = options.inSourceTests ?? false;
    return {
        ...options,
        directory,
        styledModule,
        hasStyles: options.style !== 'none',
        className,
        fileName: componentFileName,
        projectSourceRoot,
    };
}
async function getDirectory(host, options) {
    const genNames = (0, devkit_1.names)(options.name);
    const fileName = options.pascalCaseDirectory === true
        ? genNames.className
        : genNames.fileName;
    const workspace = (0, devkit_1.getProjects)(host);
    let baseDir;
    if (options.directory) {
        baseDir = options.directory;
    }
    else {
        baseDir =
            workspace.get(options.project).projectType === 'application'
                ? 'app'
                : 'lib';
    }
    return options.flat ? baseDir : (0, devkit_1.joinPathFragments)(baseDir, fileName);
}
function assertValidOptions(options) {
    (0, assertion_1.assertValidStyle)(options.style);
    const slashes = ['/', '\\'];
    slashes.forEach((s) => {
        if (options.name.indexOf(s) !== -1) {
            const [name, ...rest] = options.name.split(s).reverse();
            let suggestion = rest.map((x) => x.toLowerCase()).join(s);
            if (options.directory) {
                suggestion = `${options.directory}${s}${suggestion}`;
            }
            throw new Error(`Found "${s}" in the component name. Did you mean to use the --directory option (e.g. \`nx g c ${name} --directory ${suggestion}\`)?`);
        }
    });
}
exports.default = componentGenerator;
exports.componentSchematic = (0, devkit_1.convertNxGenerator)(componentGenerator);
